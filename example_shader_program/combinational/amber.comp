#version 450
#pragma scheduler(HSA)
#extension GL_KHR_shader_subgroup_basic : enable
#extension GL_KHR_memory_scope_semantics : enable
#extension GL_KHR_shader_subgroup_vote : enable
#extension GL_KHR_shader_subgroup_ballot : enable
layout(local_size_x = 1) in;
layout(tla_subgroup_size = 1) in;
layout(tla_num_workgroups = 2) in;

layout(std430, binding = 0) buffer PickThread {
    uint pick_thread;
};

layout(std430, binding = 1) buffer Test {
    uint test;
};

void main(){
        // 6
        uint gid_x = gl_GlobalInvocationID.x;
             
        // launch with many threads per workgroup
        uint wg_id = gl_WorkGroupID.x;
        uint sg_id = gl_SubgroupID;
        uint round_robin = 0;

        uint pc = 0;

        // First thread turns into first subgroup in first workgroup
        //if (gid_x == 0) {
        if (wg_id == 0 && sg_id == 0) { // selection header block: 24
        // 27
           int terminate = 0;

            while (true) { // loop header block: 30
            // 32
                // if (terminate == 1) { // selection header block: 36
                if (subgroupAny(terminate == 1)){
                    break;
                }
        

                // pick a representative thread in the subgroup
                pick_thread = round_robin % gl_SubgroupSize;
                if (gl_SubgroupInvocationID == pick_thread) {
                    // maybe change these to if/else
                    switch(pc) { 
                        case 0:
                            if (atomicAdd(test, 0) == 0 ) {
                                pc = 0;
                            }
                            else {
                            pc = pc + 1;
                            }
                            break;
                        case 1:
                            terminate = 1;
                            break;
                    }
                }
                pc = subgroupBroadcast(pc, pick_thread);
                round_robin+=1;
            }
                // merge block for selection: 76
        }
        // merge block for selection: 83

        if (wg_id == 0 && sg_id == 0) {
           int terminate = 0;

            while (true) {
                    if (subgroupAny(terminate == 1)){
                        break;
                    }
        

                // pick a representative thread in the subgroup
                pick_thread = round_robin % gl_SubgroupSize;
                if (gl_SubgroupInvocationID == pick_thread) {
                    // maybe change these to if/else
                    switch(pc) { 
                        case 0:
                            atomicExchange(test, 1);
                            pc = pc + 1;
                            break;
                        case 1:
                            terminate = 1;
                            break;
                    }
                }
                pc = subgroupBroadcast(pc, pick_thread);
                round_robin+=1;
            }
        }
    barrier();
}